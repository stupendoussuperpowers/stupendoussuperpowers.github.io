[{"name":"blocks.0","value":{"rawText":"Earlier this month, I had the opportunity to present a talk at the SBOMit meeting taking place at KubeCon + CNCF in Atalanta.","renderText":"<p>Earlier this month, I had the opportunity to present a talk at the SBOMit meeting taking place at KubeCon + CNCF in Atalanta.</p>\n","id":"id_637006.4236075133"},"rawText":"Earlier this month, I had the opportunity to present a talk at the SBOMit meeting taking place at [KubeCon + CNCF in Atlanta.](https://events.linuxfoundation.org/kubecon-cloudnativecon-north-america/)","renderText":"<p>Earlier this month, I had the opportunity to present a talk at the SBOMit meeting taking place at <a href=\"https://events.linuxfoundation.org/kubecon-cloudnativecon-north-america/\" target=\"_blank\">KubeCon + CNCF in Atlanta.</a></p>\n"},{"name":"blocks.1","value":{"id":"id_634788.5508608089","rawText":"For the uninitiated, [SBOMit](https://sbomit.dev) is a an Open Source Security Foundation project that aims to improve the information that an SBOM contains, through the use of [in-toto]() attestations.","renderText":"<p>For the uninitiated, <a href=\"https://sbomit.dev\" target=\"_blank\">SBOMit</a> is a an Open Source Security Foundation project that aims to improve the information that an SBOM contains, through the use of <a href=\"\" target=\"_blank\">in-toto</a> attestations.</p>\n"},"rawText":"For the uninitiated, [SBOMit](https://sbomit.dev) is a an Open Source Security Foundation project that aims to improve the information that an SBOM (Software Bill of Materials) contains, through the use of [in-toto](https://in-toto.io/) attestations.","renderText":"<p>For the uninitiated, <a href=\"https://sbomit.dev\" target=\"_blank\">SBOMit</a> is a an Open Source Security Foundation project that aims to improve the information that an SBOM (Software Bill of Materials) contains, through the use of <a href=\"https://in-toto.io/\" target=\"_blank\">in-toto</a> attestations.</p>\n"},{"name":"blocks.2","value":{"id":"id_22333.75383747638","rawText":"Briefly motivating the problem, SBOMs are often used as a provenance tool meant to include information about the packages that were either directly or indirectly used when building a software package. \n\nHowever, most of these tools fall short in several ways. For one, they usually rely only on manifest files and output artifacts to detect these ingredients. These are often unreliable because something as simple as a stale lockfile or ambiguous requirements can lead to inaccurate versions being attached to your SBOM. This runs into even more complicated issues if you are using a multi-language environment such as maturin, where it's possible that the SBOM completely ignores packages that aren't directly listed in a manifest. \n\nThese tools often also need to be tailor-built for individual environments. For e.g. you'd need separate codepaths for detecting a Cargo.toml and requirements.txt file. \n\nMoreover, since these tools are meant to be used as a provenance tool, it is imperative that these be independently verifiable and be susceptible to tampering. While this is achievable using existing tools, they're often not a first-class feature.","renderText":"<p>Briefly motivating the problem, SBOMs are often used as a provenance tool meant to include information about the packages that were either directly or indirectly used when building a software package.</p>\n<p>However, most of these tools fall short in several ways. For one, they usually rely only on manifest files and output artifacts to detect these ingredients. These are often unreliable because something as simple as a stale lockfile or ambiguous requirements can lead to inaccurate versions being attached to your SBOM. This runs into even more complicated issues if you are using a multi-language environment such as maturin, where it's possible that the SBOM completely ignores packages that aren't directly listed in a manifest.</p>\n<p>These tools often also need to be tailor-built for individual environments. For e.g. you'd need separate codepaths for detecting a Cargo.toml and requirements.txt file.</p>\n<p>Moreover, since these tools are meant to be used as a provenance tool, it is imperative that these be independently verifiable and be susceptible to tampering. While this is achievable using existing tools, they're often not a first-class feature.</p>\n"},"rawText":"Briefly motivating the problem, SBOMs are often used as a provenance tool meant to include information about the packages that were either directly or indirectly used when building a software package. \n\nHowever, most of these tools fall short in several ways. For one, they usually rely only on manifest files and output artifacts to detect these ingredients. These are often unreliable because something as simple as a stale lockfile or ambiguous requirements can lead to inaccurate versions being attached to your SBOM. This runs into even more complicated issues if you are using a multi-language environment such as maturin, where it's possible that the SBOM completely ignores packages that aren't directly listed in a manifest. \n\nThese tools often also need to be tailor-built for individual environments. For e.g. you'd need separate codepaths for detecting a Cargo.toml and requirements.txt file. \n\nMoreover, since these tools are meant to be used as a provenance tool, it is imperative that these be independently verifiable and be susceptible to tampering. While this is achievable using existing tools, they're often not a first-class feature.","renderText":"<p>Briefly motivating the problem, SBOMs are often used as a provenance tool meant to include information about the packages that were either directly or indirectly used when building a software package.</p>\n<p>However, most of these tools fall short in several ways. For one, they usually rely only on manifest files and output artifacts to detect these ingredients. These are often unreliable because something as simple as a stale lockfile or ambiguous requirements can lead to inaccurate versions being attached to your SBOM. This runs into even more complicated issues if you are using a multi-language environment such as maturin, where it's possible that the SBOM completely ignores packages that aren't directly listed in a manifest.</p>\n<p>These tools often also need to be tailor-built for individual environments. For e.g. you'd need separate codepaths for detecting a Cargo.toml and requirements.txt file.</p>\n<p>Moreover, since these tools are meant to be used as a provenance tool, it is imperative that these be independently verifiable and be susceptible to tampering. While this is achievable using existing tools, they're often not a first-class feature.</p>\n"},{"name":"blocks.3","value":{"id":"id_142483.8915985023","rawText":"SBOMit tries to fix some of these problems through the use of in-toto through attestations that provide a more granular detail of the packages and files that were used during the build stage, and can make it easier to detect untoward behavior through the use of policies and layouts. \n\nSBOMit isn't meant to be a SBOM generation tool, but rather it is an effort to augment existing SBOM tools with the additional information and security that in-toto provides.","renderText":"<p>SBOMit tries to fix some of these problems through the use of in-toto through attestations that provide a more granular detail of the packages and files that were used during the build stage, and can make it easier to detect untoward behavior through the use of policies and layouts.</p>\n<p>SBOMit isn't meant to be a SBOM generation tool, but rather it is an effort to augment existing SBOM tools with the additional information and security that in-toto provides.</p>\n"},"rawText":"SBOMit tries to fix some of these problems through the use of in-toto through attestations that provide a more granular detail of the packages and files that were used during the build stage, and can make it easier to detect untoward behavior through the use of policies and layouts. \n\nInstead of relying solely on manifests, we observe the build process as well.\n\nSBOMit isn't meant to be a SBOM generation tool, but rather it is an effort to augment existing SBOM tools with the additional information and security that in-toto provides.","renderText":"<p>SBOMit tries to fix some of these problems through the use of in-toto through attestations that provide a more granular detail of the packages and files that were used during the build stage, and can make it easier to detect untoward behavior through the use of policies and layouts.</p>\n<p>Instead of relying solely on manifests, we observe the build process as well.</p>\n<p>SBOMit isn't meant to be a SBOM generation tool, but rather it is an effort to augment existing SBOM tools with the additional information and security that in-toto provides.</p>\n"},{"name":"blocks.4","value":{"id":"id_415444.76690796216","rawText":"For our presentation, we demoed our tool which was a modified version of [syft]() that took as an additional the attestations generated through [witness](). \n\nWe also further added support for [network attestations](https://github.com/stupendoussuperpowers/witness.git) to witness making it possible to record information about where the packages were pulled from, and if the build process made suspicious network calls. This helps in cases where typosquatting or dependency confusion is a viable vector of attack. ","renderText":"<p>For our presentation, we demoed our tool which was a modified version of <a href=\"\" target=\"_blank\">syft</a> that took as an additional the attestations generated through <a href=\"\" target=\"_blank\">witness</a>.</p>\n<p>We also further added support for <a href=\"https://github.com/stupendoussuperpowers/witness.git\" target=\"_blank\">network attestations</a> to witness making it possible to record information about where the packages were pulled from, and if the build process made suspicious network calls. This helps in cases where typosquatting or dependency confusion is a viable vector of attack.</p>\n"},"rawText":"For our presentation, we demoed our tool which was a modified version of [syft](https://github.com/anchore/syft) that took as an additional the attestations generated through [witness](https://github.com/in-toto/witness). \n\nWe also further added support for [network attestations](https://github.com/stupendoussuperpowers/witness/tree/network-tracing) to witness making it possible to record information about where the packages were pulled from, and if the build process made suspicious network calls. This helps in cases where typosquatting or dependency confusion is a viable vector of attack. ","renderText":"<p>For our presentation, we demoed our tool which was a modified version of <a href=\"https://github.com/anchore/syft\" target=\"_blank\">syft</a> that took as an additional the attestations generated through <a href=\"https://github.com/in-toto/witness\" target=\"_blank\">witness</a>.</p>\n<p>We also further added support for <a href=\"https://github.com/stupendoussuperpowers/witness/tree/network-tracing\" target=\"_blank\">network attestations</a> to witness making it possible to record information about where the packages were pulled from, and if the build process made suspicious network calls. This helps in cases where typosquatting or dependency confusion is a viable vector of attack.</p>\n"},{"id":"id_599384.5273371876","rawText":"[Check out our presentation here!](https://docs.google.com/presentation/d/1emx0rUjpSx3xzSw0dILDC0Oegb2i076bre8KJQcFPz8/edit?usp=sharing)","renderText":"<p><a href=\"https://docs.google.com/presentation/d/1emx0rUjpSx3xzSw0dILDC0Oegb2i076bre8KJQcFPz8/edit?usp=sharing\" target=\"_blank\">Check out our presentation here!</a></p>\n"}]