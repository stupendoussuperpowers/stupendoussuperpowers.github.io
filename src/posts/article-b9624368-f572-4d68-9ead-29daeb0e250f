[{"name":"blocks.0","value":{"name":"blocks.0","value":{"rawText":"## f 0: So what is HFS+, and what is FreeBSD? And how does porting a filesystem work?\n\n","renderText":"<h2>f 0: So what is HFS+, and what is FreeBSD? And how does porting a filesystem work?</h2>\n","id":"id_985991.7190729653"},"rawText":"* f 0: So what is HFS+, and what is FreeBSD? And how does porting a filesystem work? *\n","renderText":"<ul>\n<li>f 0: So what is HFS+, and what is FreeBSD? And how does porting a filesystem work? *</li>\n</ul>\n"},"rawText":"Earlier this year I wandered into a proposal for porting HFS+ to FreeBSD, an endeavor that was [attempted](https://web.archive.org/web/20090603104308/http://people.freebsd.org/~yar/hfs/) once before in the early oughts for FreeBSD 5. When I read through this proposal, I had never heard of the HFS+ filesystem, and had very little technical insights into how FreeBSD worked (or how it differs from other BSDs and Linux), and very little information on how to write a filesystem for it. Naturally, I felt I'd be able to contribute this project. The only thing in my way was everything, but I reckoned if an infinite number of monkeys can use infinite amount of time to write all of Shakespeare, maybe I could port a filesystem too, after all I am much smarter than a monkey.\n\nAs of writing this, the [freebsd_hfs](https://github.com/stupendoussuperpowers/freebsd_hfs) port has read and write support without journalling. Through this post I will attempt to take you along my journey, from the top of the \"stack frame\" to the very bottom, one pop() at a time.","renderText":"<p>Earlier this year I wandered into a proposal for porting HFS+ to FreeBSD, an endeavor that was <a href=\"https://web.archive.org/web/20090603104308/http://people.freebsd.org/~yar/hfs/\" target=\"_blank\">attempted</a> once before in the early oughts for FreeBSD 5. When I read through this proposal, I had never heard of the HFS+ filesystem, and had very little technical insights into how FreeBSD worked (or how it differs from other BSDs and Linux), and very little information on how to write a filesystem for it. Naturally, I felt I'd be able to contribute this project. The only thing in my way was everything, but I reckoned if an infinite number of monkeys can use infinite amount of time to write all of Shakespeare, maybe I could port a filesystem too, after all I am much smarter than a monkey.</p>\n<p>As of writing this, the <a href=\"https://github.com/stupendoussuperpowers/freebsd_hfs\" target=\"_blank\">freebsd_hfs</a> port has read and write support without journalling. Through this post I will attempt to take you along my journey, from the top of the &quot;stack frame&quot; to the very bottom, one pop() at a time.</p>\n"},{"id":"id_368875.648914343","rawText":"**f 0: HFS+, FreeBSD**","renderText":"<p><strong>f 0: HFS+, FreeBSD</strong></p>\n"},{"name":"blocks.2","value":{"id":"id_170544.4808557055","rawText":"Let's begin by beginning. (H)ierarchical (F)ile (S)ystem is a now out-of-use filesystem developed by Apple that used to be the default Volume format for XNU/Darwin prior to the introduction of the current APFS filesystem. Today, most places that you see HFS Volumes are old Apple devices like the old-school iPods. If you run macOS, you can create your very own HFS+ image using `hdiutil`. The '+' at the end indicates a more modern variant of HFS which supports journaling. HFS is natively supported on many other Operating Systems as well such as Linux and NetBSD. \n\nNow, coming to \"XNU/Darwin\" and FreeBSD. For the purposes of this post and the project, it is only relevant to know that XNU and FreeBSD share a lot of components in common, and both belong to the wide-and-varied BSD family tree which can find it's roots at UC Berkeley's Berkeley Software Division. ","renderText":"<p>Let's begin by beginning. (H)ierarchical (F)ile (S)ystem is a now out-of-use filesystem developed by Apple that used to be the default Volume format for XNU/Darwin prior to the introduction of the current APFS filesystem. Today, most places that you see HFS Volumes are old Apple devices like the old-school iPods. If you run macOS, you can create your very own HFS+ image using <code>hdiutil</code>. The '+' at the end indicates a more modern variant of HFS which supports journaling. HFS is natively supported on many other Operating Systems as well such as Linux and NetBSD.</p>\n<p>Now, coming to &quot;XNU/Darwin&quot; and FreeBSD. For the purposes of this post and the project, it is only relevant to know that XNU and FreeBSD share a lot of components in common, and both belong to the wide-and-varied BSD family tree which can find it's roots at UC Berkeley's Berkeley Software Division.</p>\n"},"rawText":"Let's begin by beginning. [(H)ierarchical (F)ile (S)ystem](https://developer.apple.com/library/archive/technotes/tn/tn1150.html) is a now out-of-use filesystem developed by Apple that used to be the default Volume format for XNU/Darwin prior to the introduction of the current APFS filesystem. The '+' at the end indicates a variant of HFS which supports journalling. Today, most places that you see HFS Volumes are old Apple devices like the old-school iPods. If you run macOS, you can create your very own HFS+ image using `hdiutil`. HFS is natively supported on many other Operating Systems as well such as Linux and NetBSD. \n\nFor now it is only relevant to know that [XNU/Darwin](https://tansanrao.com/blog/2025/04/xnu-kernel-and-darwin-evolution-and-architecture/) and FreeBSD share a lot of components in common, and both belong to the wide-and-varied BSD [family tree](https://en.wikipedia.org/wiki/History_of_the_Berkeley_Software_Distribution#/media/File:Unix_history-simple.svg) which can find its roots at UC Berkeley's Software Division. The source code for [XNU and HFS](https://github.com/apple-oss-distributions/hfs) are open-sourced by Apple.","renderText":"<p>Let's begin by beginning. <a href=\"https://developer.apple.com/library/archive/technotes/tn/tn1150.html\" target=\"_blank\">(H)ierarchical (F)ile (S)ystem</a> is a now out-of-use filesystem developed by Apple that used to be the default Volume format for XNU/Darwin prior to the introduction of the current APFS filesystem. The '+' at the end indicates a variant of HFS which supports journalling. Today, most places that you see HFS Volumes are old Apple devices like the old-school iPods. If you run macOS, you can create your very own HFS+ image using <code>hdiutil</code>. HFS is natively supported on many other Operating Systems as well such as Linux and NetBSD.</p>\n<p>For now it is only relevant to know that <a href=\"https://tansanrao.com/blog/2025/04/xnu-kernel-and-darwin-evolution-and-architecture/\" target=\"_blank\">XNU/Darwin</a> and FreeBSD share a lot of components in common, and both belong to the wide-and-varied BSD <a href=\"https://en.wikipedia.org/wiki/History_of_the_Berkeley_Software_Distribution#/media/File:Unix_history-simple.svg\" target=\"_blank\">family tree</a> which can find its roots at UC Berkeley's Software Division. The source code for <a href=\"https://github.com/apple-oss-distributions/hfs\" target=\"_blank\">XNU and HFS</a> are open-sourced by Apple.</p>\n"},{"name":"blocks.3","value":{"id":"id_647556.0942565086","rawText":"**f 1: Virtual File Systems**","renderText":"<p><strong>f 1: Virtual File Systems</strong></p>\n"},"rawText":"**f 1: Virtual File Systems**","renderText":"<p><strong>f 1: Virtual File Systems</strong></p>\n"},{"name":"blocks.4","value":{"id":"id_85307.85505996697","rawText":"The Virtual File System is a standard technique used by Operating Systems that wish to support multiple file-systems. In essence, the VFS allows the kernel to defer the responsibility for the implementation to individual modules for a specific FS. In order for a module to be recognized as a filesystem, it needs to expose a list of standard VOP (vnode operations) and VFS functions. VFS functions handle filesystem level operations such as mounting, unmounting, stats, etc. VOP functions handle vnode specific operations such as reads, writes, links, etc.\n\nEach of these functions have a specific function signature, which enforce the inputs and outputs the function deals with and what the lock state are supposed to be. These are documented in man. For example here's a brief excerpt for `man VOP_WRITE` which deals with writing data to a vnode. \n\n```\nDESCRIPTION\n       These entry points read or write\tthe contents of\ta file.\n\n       The arguments are:\n\n       vp      The vnode of the\tfile.\n\n       uio     The location of the data\tto be read or written.\n\n       ioflag  Various flags.\n\n       cnp     The credentials of the caller.\n\nLOCKS\n       The file\tshould be locked on entry and will still be  locked  on\t exit.\n       Rangelock covering the whole i/o\trange should be\towned around the call.\n\nRETURN VALUES\n       Zero is returned\ton success, otherwise an error code is returned.\n```","renderText":"<p>The Virtual File System is a standard technique used by Operating Systems that wish to support multiple file-systems. In essence, the VFS allows the kernel to defer the responsibility for the implementation to individual modules for a specific FS. In order for a module to be recognized as a filesystem, it needs to expose a list of standard VOP (vnode operations) and VFS functions. VFS functions handle filesystem level operations such as mounting, unmounting, stats, etc. VOP functions handle vnode specific operations such as reads, writes, links, etc.</p>\n<p>Each of these functions have a specific function signature, which enforce the inputs and outputs the function deals with and what the lock state are supposed to be. These are documented in man. For example here's a brief excerpt for <code>man VOP_WRITE</code> which deals with writing data to a vnode.</p>\n<pre><code>DESCRIPTION\n       These entry points read or write\tthe contents of\ta file.\n\n       The arguments are:\n\n       vp      The vnode of the\tfile.\n\n       uio     The location of the data\tto be read or written.\n\n       ioflag  Various flags.\n\n       cnp     The credentials of the caller.\n\nLOCKS\n       The file\tshould be locked on entry and will still be  locked  on\t exit.\n       Rangelock covering the whole i/o\trange should be\towned around the call.\n\nRETURN VALUES\n       Zero is returned\ton success, otherwise an error code is returned.\n</code></pre>\n"},"rawText":"The Virtual File System is a standard technique used by Operating Systems that wish to support multiple file-systems. In essence, the VFS allows the kernel to defer the responsibility for the implementation to individual modules for a specific FS. In order for a module to be recognized as a filesystem, it needs to expose a list of standard VOP (vnode operations) and VFS functions. VFS functions handle filesystem level operations such as mounting, unmounting, stats, etc. VOP functions handle vnode specific operations such as reads, writes, links, etc.\n\nEach of these functions have a specific function signature, which enforce the inputs and outputs the function deals with and what the lock state are supposed to be. These are documented in man. For example here's a brief excerpt for `man VOP_WRITE` which deals with writing data to a vnode. \n\n```\nDESCRIPTION\n       These entry points read or write\tthe contents of\ta file.\n\n       The arguments are:\n\n       vp      The vnode of the\tfile.\n\n       uio     The location of the data\tto be read or written.\n\n       ioflag  Various flags.\n\n       cnp     The credentials of the caller.\n\nLOCKS\n       The file\tshould be locked on entry and will still be  locked  on\t exit.\n       Rangelock covering the whole i/o\trange should be\towned around the call.\n\nRETURN VALUES\n       Zero is returned\ton success, otherwise an error code is returned.\n```","renderText":"<p>The Virtual File System is a standard technique used by Operating Systems that wish to support multiple file-systems. In essence, the VFS allows the kernel to defer the responsibility for the implementation to individual modules for a specific FS. In order for a module to be recognized as a filesystem, it needs to expose a list of standard VOP (vnode operations) and VFS functions. VFS functions handle filesystem level operations such as mounting, unmounting, stats, etc. VOP functions handle vnode specific operations such as reads, writes, links, etc.</p>\n<p>Each of these functions have a specific function signature, which enforce the inputs and outputs the function deals with and what the lock state are supposed to be. These are documented in man. For example here's a brief excerpt for <code>man VOP_WRITE</code> which deals with writing data to a vnode.</p>\n<pre><code>DESCRIPTION\n       These entry points read or write\tthe contents of\ta file.\n\n       The arguments are:\n\n       vp      The vnode of the\tfile.\n\n       uio     The location of the data\tto be read or written.\n\n       ioflag  Various flags.\n\n       cnp     The credentials of the caller.\n\nLOCKS\n       The file\tshould be locked on entry and will still be  locked  on\t exit.\n       Rangelock covering the whole i/o\trange should be\towned around the call.\n\nRETURN VALUES\n       Zero is returned\ton success, otherwise an error code is returned.\n</code></pre>\n"},{"name":"blocks.5","value":{"id":"id_67766.02358222117","rawText":"**f 2: A kernel module appears**\n\nThe easiest way to implement a filesystem is through a kernel module. ","renderText":"<p><strong>f 2: A kernel module appears</strong></p>\n<p>The easiest way to implement a filesystem is through a kernel module.</p>\n"},"rawText":"**f 2: A kernel module appears**\n\n","renderText":"<p><strong>f 2: A kernel module appears</strong></p>\n"},{"name":"blocks.6","value":{"id":"id_654052.9454791297","rawText":"\nThe easiest way to implement a filesystem is through a kernel module. To register our kmod as a filesystem, we use the VFS_SET macro with our vfs function table which lets our kernel know that it has a new recognized filesystem type, and it also handles the init and unload functions for the module. \n\n\\# [hfsplus/hfs_vfsops.c](/)\n```\nstatic struct vfsops hfs_vfsops = {\n\t.vfs_mount = hfs_mount,\n\t.vfs_root = hfs_root,\n        ...\n};\n\nVFS_SET(hfs_vfsops, hfs, 0);\n```\n\nWe also need to register our VOP function table. \n\n\\# [hfsplus/hfs_vnops.c](/)\n```\nstruct vop_vector hfs_vnodeops = {\n\t.vop_default = &default_vnodeops,\n\t.vop_close = hfs_close,\n\t.vop_mkdir = hfs_mkdir,\n\t.vop_open = hfs_open,\n\t.vop_read = hfs_read,\n        ...\n}\n\nVFS_VOP_VECTOR_REGISTER(hfs_vnodeops);\n```\n\nAs long as our functions have the appropriate signature and return an appropriate return code, the kernel will be happy and shouldn't panic. ","renderText":"<p>The easiest way to implement a filesystem is through a kernel module. To register our kmod as a filesystem, we use the VFS_SET macro with our vfs function table which lets our kernel know that it has a new recognized filesystem type, and it also handles the init and unload functions for the module.</p>\n<p># <a href=\"/\">hfsplus/hfs_vfsops.c</a></p>\n<pre><code>static struct vfsops hfs_vfsops = {\n\t.vfs_mount = hfs_mount,\n\t.vfs_root = hfs_root,\n        ...\n};\n\nVFS_SET(hfs_vfsops, hfs, 0);\n</code></pre>\n<p>We also need to register our VOP function table.</p>\n<p># <a href=\"/\">hfsplus/hfs_vnops.c</a></p>\n<pre><code>struct vop_vector hfs_vnodeops = {\n\t.vop_default = &amp;default_vnodeops,\n\t.vop_close = hfs_close,\n\t.vop_mkdir = hfs_mkdir,\n\t.vop_open = hfs_open,\n\t.vop_read = hfs_read,\n        ...\n}\n\nVFS_VOP_VECTOR_REGISTER(hfs_vnodeops);\n</code></pre>\n<p>As long as our functions have the appropriate signature and return an appropriate return code, the kernel will be happy and shouldn't panic.</p>\n"},"rawText":"\nThe easiest way to implement a filesystem is through a kernel module. To register our kmod as a filesystem, we use the VFS_SET macro with our vfs function table which lets our kernel know that it has a new recognized filesystem type, and it also handles the init and unload functions for the module. \n\n\\# ***hfsplus/hfs_vfsops.c***\n```\nstatic struct vfsops hfs_vfsops = {\n\t.vfs_mount = hfs_mount,\n\t.vfs_root = hfs_root,\n        ...\n};\n\nVFS_SET(hfs_vfsops, hfs, 0);\n------\n```\n\nWe also need to register our VOP function table. \n\n\\# ***hfsplus/hfs_vnops.c***\n```\nstruct vop_vector hfs_vnodeops = {\n\t.vop_default = &default_vnodeops,\n\t.vop_close = hfs_close,\n\t.vop_mkdir = hfs_mkdir,\n\t.vop_open = hfs_open,\n\t.vop_read = hfs_read,\n        ...\n}\n\nVFS_VOP_VECTOR_REGISTER(hfs_vnodeops);\n------\n```\n\nAs long as our functions have the appropriate signature and return an appropriate return code, the kernel will be happy and shouldn't panic. ","renderText":"<p>The easiest way to implement a filesystem is through a kernel module. To register our kmod as a filesystem, we use the VFS_SET macro with our vfs function table which lets our kernel know that it has a new recognized filesystem type, and it also handles the init and unload functions for the module.</p>\n<p># <em><strong>hfsplus/hfs_vfsops.c</strong></em></p>\n<pre><code>static struct vfsops hfs_vfsops = {\n\t.vfs_mount = hfs_mount,\n\t.vfs_root = hfs_root,\n        ...\n};\n\nVFS_SET(hfs_vfsops, hfs, 0);\n------\n</code></pre>\n<p>We also need to register our VOP function table.</p>\n<p># <em><strong>hfsplus/hfs_vnops.c</strong></em></p>\n<pre><code>struct vop_vector hfs_vnodeops = {\n\t.vop_default = &amp;default_vnodeops,\n\t.vop_close = hfs_close,\n\t.vop_mkdir = hfs_mkdir,\n\t.vop_open = hfs_open,\n\t.vop_read = hfs_read,\n        ...\n}\n\nVFS_VOP_VECTOR_REGISTER(hfs_vnodeops);\n------\n</code></pre>\n<p>As long as our functions have the appropriate signature and return an appropriate return code, the kernel will be happy and shouldn't panic.</p>\n"},{"name":"blocks.7","value":{"id":"id_489661.2450736002","rawText":"\n**f 3: So about that port**","renderText":"<p><strong>f 3: So about that port</strong></p>\n"},"rawText":"\n**f 3: So about that port**","renderText":"<p><strong>f 3: So about that port</strong></p>\n"},{"name":"blocks.8","value":{"id":"id_275001.5946486964","rawText":"To actually make these functions, well, functional, we need a few things. 1. We need a way to actually read and write data onto disk. 2. We need to populate these functions to call these read/write methods, which also populate the correct structs and return the correct codes. As you can probably guess, writing all of this from the ground up is a monumental feat, which requires a much higher level of craft and attention to detail. Luckily for us, this is where the open-sourced HFS source code and XNU's shared bloodlines with BSD come in handy for us. \n\nTo begin with 1., the [hfscommon](/) folder contains a bunch of standalone util functions which can take raw data and offsets and convert them into BTree blocks which are readily traversable. And for 2., Given that shared bloodline, most changes from XNU to BSD where fairly trivial - in most cases the core data-flow and operations remained the same, and some tweaks were required to adapt to FreeBSD's VOP_ or VFS_ function signatures. \n\nMost of this work was already done by [yars' port](/), however this was done for FreeBSD 5. Most if not all the VFS/VOP functions have since changed. Let's list some of these in a rapid fire round:\n- VOP_ functions don't take a `thread` argument anymore. \n- VOP_UNLOCK and several other functions do not need the flags the LOCK was set with. \n- XNU had different signatures for MALLOC and FREE. \n- To get sector info, we need to use geom APIs instead of IOCTL.\n- Changing int32 pointers, and pointer arithmetic. ","renderText":"<p>To actually make these functions, well, functional, we need a few things. 1. We need a way to actually read and write data onto disk. 2. We need to populate these functions to call these read/write methods, which also populate the correct structs and return the correct codes. As you can probably guess, writing all of this from the ground up is a monumental feat, which requires a much higher level of craft and attention to detail. Luckily for us, this is where the open-sourced HFS source code and XNU's shared bloodlines with BSD come in handy for us.</p>\n<p>To begin with 1., the <a href=\"/\">hfscommon</a> folder contains a bunch of standalone util functions which can take raw data and offsets and convert them into BTree blocks which are readily traversable. And for 2., Given that shared bloodline, most changes from XNU to BSD where fairly trivial - in most cases the core data-flow and operations remained the same, and some tweaks were required to adapt to FreeBSD's VOP_ or VFS_ function signatures.</p>\n<p>Most of this work was already done by <a href=\"/\">yars' port</a>, however this was done for FreeBSD 5. Most if not all the VFS/VOP functions have since changed. Let's list some of these in a rapid fire round:</p>\n<ul>\n<li>VOP_ functions don't take a <code>thread</code> argument anymore.</li>\n<li>VOP_UNLOCK and several other functions do not need the flags the LOCK was set with.</li>\n<li>XNU had different signatures for MALLOC and FREE.</li>\n<li>To get sector info, we need to use geom APIs instead of IOCTL.</li>\n<li>Changing int32 pointers, and pointer arithmetic.</li>\n</ul>\n"},"rawText":"To actually make these functions, well, functional, we need a few things. 1. We need a way to actually read and write data onto disk. 2. We need to populate these functions to call these read/write methods, which also populate the correct structs and return the correct codes. As you can probably guess, writing all of this from the ground up is a monumental feat, which requires a much higher level of craft and attention to detail. Luckily for us, this is where the open-sourced HFS source code and XNU's shared bloodlines with BSD come in handy for us. \n\nTo begin with 1., the [hfscommon](https://github.com/stupendoussuperpowers/freebsd_hfs/tree/main/hfsplus) folder contains a bunch of standalone util functions which can take raw data and offsets and convert them into BTree blocks which are readily traversable. And for 2., Given that shared bloodline, most changes from XNU to BSD where fairly trivial - in most cases the core data-flow and operations remained the same, and some tweaks were required to adapt to FreeBSD's VOP_ or VFS_ function signatures. \n\nMost of this work was already done by [yars' port](https://web.archive.org/web/20090603104308/http://people.freebsd.org/~yar/hfs/), however this was done for FreeBSD 5. Most if not all the VFS/VOP functions have since changed. Let's list some of these in a rapid fire round:\n- VOP_ functions don't take a `thread` argument anymore. \n- VOP_UNLOCK and several other functions do not need the flags the LOCK was set with. \n- XNU had different signatures for MALLOC and FREE. \n- To get sectorsize and mediasize, use geom APIs instead of IOCTL.\n- Use insmntqueue() to register a vnode. \n- Changing int32 pointers, and pointer arithmetic. ","renderText":"<p>To actually make these functions, well, functional, we need a few things. 1. We need a way to actually read and write data onto disk. 2. We need to populate these functions to call these read/write methods, which also populate the correct structs and return the correct codes. As you can probably guess, writing all of this from the ground up is a monumental feat, which requires a much higher level of craft and attention to detail. Luckily for us, this is where the open-sourced HFS source code and XNU's shared bloodlines with BSD come in handy for us.</p>\n<p>To begin with 1., the <a href=\"https://github.com/stupendoussuperpowers/freebsd_hfs/tree/main/hfsplus\" target=\"_blank\">hfscommon</a> folder contains a bunch of standalone util functions which can take raw data and offsets and convert them into BTree blocks which are readily traversable. And for 2., Given that shared bloodline, most changes from XNU to BSD where fairly trivial - in most cases the core data-flow and operations remained the same, and some tweaks were required to adapt to FreeBSD's VOP_ or VFS_ function signatures.</p>\n<p>Most of this work was already done by <a href=\"https://web.archive.org/web/20090603104308/http://people.freebsd.org/~yar/hfs/\" target=\"_blank\">yars' port</a>, however this was done for FreeBSD 5. Most if not all the VFS/VOP functions have since changed. Let's list some of these in a rapid fire round:</p>\n<ul>\n<li>VOP_ functions don't take a <code>thread</code> argument anymore.</li>\n<li>VOP_UNLOCK and several other functions do not need the flags the LOCK was set with.</li>\n<li>XNU had different signatures for MALLOC and FREE.</li>\n<li>To get sectorsize and mediasize, use geom APIs instead of IOCTL.</li>\n<li>Use insmntqueue() to register a vnode.</li>\n<li>Changing int32 pointers, and pointer arithmetic.</li>\n</ul>\n"},{"name":"blocks.9","value":{"id":"id_232910.51416329943","rawText":"**f 4: You listed a thousand keywords, weren't you new to this?**","renderText":"<p><strong>f 4: You listed a thousand keywords, weren't you new to this?</strong></p>\n"},"rawText":"**f 4: You listed a thousand keywords, weren't you new to this?**","renderText":"<p><strong>f 4: You listed a thousand keywords, weren't you new to this?</strong></p>\n"},{"name":"blocks.10","value":{"id":"id_176078.23798209243","rawText":"Yes, nothing I said would have registered to me had I read it before working on this project, and nothing I say will elucidate what they are *actually* meant to mean. The only useful analysis I can provide is an account for my journey, how I figured out what was wrong, what needed fixing, and where to even to start. \n","renderText":"<p>Yes, nothing I said would have registered to me had I read it before working on this project, and nothing I say will elucidate what they are <em>actually</em> meant to mean. The only useful analysis I can provide is an account for my journey, how I figured out what was wrong, what needed fixing, and where to even to start.</p>\n"},"rawText":"Yes, nothing I said would have registered to me had I read it before working on this project, and nothing I say will elucidate what they are *actually* meant to mean. The only useful analysis I can provide is an account for my journey, how I figured out what was wrong, what needed fixing, and where to even to start. ","renderText":"<p>Yes, nothing I said would have registered to me had I read it before working on this project, and nothing I say will elucidate what they are <em>actually</em> meant to mean. The only useful analysis I can provide is an account for my journey, how I figured out what was wrong, what needed fixing, and where to even to start.</p>\n"},{"name":"blocks.11","value":{"id":"id_85251.57132038397","rawText":"**f 5: Let's begin by beginning, a second time**","renderText":"<p><strong>f 5: Let's begin by beginning, a second time</strong></p>\n"},"rawText":"**f 5: Let's begin by beginning, a second time**","renderText":"<p><strong>f 5: Let's begin by beginning, a second time</strong></p>\n"},{"name":"blocks.12","value":{"id":"id_575322.1118505506","rawText":"Working on this project was pretty nebulous, unlike most of my prior experiences there was no neat little documentation page to copy-paste some code from to get started, neither were there a thousand guides on the do's and dont's, or even a blog post trying to build something that was exactly like what I was building. For the most part, I was on my own, I had nothing apart from a compiler, a debugger, a bunch of manual pages, the source code for a bunch of different filesystems already integrated in the FreeBSD kernel, and a really helpful mentor, and a pretty active mailing list. On my own. \n\nHere's the general flow I followed over the course of this project:\n\n- First, create a generic stubbed function which does nothing more than logging what function was called. \n```\n```\n- Second, try to invoke a filesystem operation. For example - mount, or ls. Take a note of which function was actually getting called. This gives you a general idea of the entry and exit points for any given fs operation. \n- Third, copy the function from the old port, wrestle with compiler warnings, linker warnings and kernel panics. \n- Go back to step 2, repeat until you are stuck, or if the operation does what it is supposed to. \n\nThe issues I ran into where of the following nature for the most part:\n\n1 The compiler tells you that a function expects different signatures. This was helpful with knowing that functions like VOP_WRITE, VOP_LOCK, VOP_UNLOCK etc. take fewer arguments than they used to. \n\n2 The compiler tells you that a function does not exist, this lets you know that the canonical way to achieve something has changed. Consult a different FS code to see what. \n\n3 The linked complains, this just means (for e.g.) that hfs_mount requires certain utility features that you haven't yet implemented. \n\n4 The compiler gives you the go ahead, the linked is satisfied, you load your module, run an operation, and bam - a kernel panic. These are the best possible way for your kmod to fail, because it gives you an exact code line of where the panic occurred, and it's easier for you to know what failed, and the state of your system at the time it failed. \n\n","renderText":"<p>Working on this project was pretty nebulous, unlike most of my prior experiences there was no neat little documentation page to copy-paste some code from to get started, neither were there a thousand guides on the do's and dont's, or even a blog post trying to build something that was exactly like what I was building. For the most part, I was on my own, I had nothing apart from a compiler, a debugger, a bunch of manual pages, the source code for a bunch of different filesystems already integrated in the FreeBSD kernel, and a really helpful mentor, and a pretty active mailing list. On my own.</p>\n<p>Here's the general flow I followed over the course of this project:</p>\n<ul>\n<li>First, create a generic stubbed function which does nothing more than logging what function was called.</li>\n</ul>\n<pre><code></code></pre>\n<ul>\n<li>Second, try to invoke a filesystem operation. For example - mount, or ls. Take a note of which function was actually getting called. This gives you a general idea of the entry and exit points for any given fs operation.</li>\n<li>Third, copy the function from the old port, wrestle with compiler warnings, linker warnings and kernel panics.</li>\n<li>Go back to step 2, repeat until you are stuck, or if the operation does what it is supposed to.</li>\n</ul>\n<p>The issues I ran into where of the following nature for the most part:</p>\n<p>1 The compiler tells you that a function expects different signatures. This was helpful with knowing that functions like VOP_WRITE, VOP_LOCK, VOP_UNLOCK etc. take fewer arguments than they used to.</p>\n<p>2 The compiler tells you that a function does not exist, this lets you know that the canonical way to achieve something has changed. Consult a different FS code to see what.</p>\n<p>3 The linked complains, this just means (for e.g.) that hfs_mount requires certain utility features that you haven't yet implemented.</p>\n<p>4 The compiler gives you the go ahead, the linked is satisfied, you load your module, run an operation, and bam - a kernel panic. These are the best possible way for your kmod to fail, because it gives you an exact code line of where the panic occurred, and it's easier for you to know what failed, and the state of your system at the time it failed.</p>\n"},"rawText":"Working on this project was pretty nebulous, unlike most of my prior experiences there was no neat little documentation page to copy-paste some code from to get started, neither were there a thousand guides on the do's and dont's, or even a blog post trying to build something that was exactly like what I was building. For the most part, I was on my own, I had nothing apart from a compiler, a debugger, a bunch of manual pages, the source code for a bunch of different filesystems already integrated in the FreeBSD kernel, and a really helpful mentor, and a pretty active mailing list. As I said, all on my own.\n\nHere's the general flow I followed over the course of this project:\n\n- First, create a generic stubbed function which does nothing more than logging what function was called. \n\n\\# ***hfsplus/hfs_vnops.c***\n```\nstatic int\nlog_notsupp(struct vop_generic_args *ap)\n{\n\tif (ap->a_desc && ap->a_desc->vdesc_name) {\n\t\tprintf(\"Unimplemented vop: %s\\n\", ap->a_desc->vdesc_name);\n\t} else {\n\t\tprintf(\"Huh?\\n\");\n\t}\n\n\treturn (EOPNOTSUPP);\n}\n------\n```\n- Second, try to invoke a filesystem operation. For example - mount, or ls. Take a note of which function were called. This gives you a general idea of the entry and exit points for any given fs operation. \n- Third, copy the function from the old port, wrestle with compiler warnings, linker warnings and kernel panics. \n- Go back to step 2, repeat until you are stuck, or until the operation does what it is supposed to. \n\nThe issues I ran into where of the following nature for the most part:\n\n1 The compiler tells you that a function expects different signatures. This was helpful with knowing that functions like VOP_WRITE, VOP_LOCK, VOP_UNLOCK etc. take fewer arguments than they used to. \n\n2 The compiler tells you that a function does not exist, this lets you know that the canonical way to achieve something has changed. Consult a different FS code to see what. \n\n3 The linked complains, this just means (for e.g.) that hfs_mount requires certain utility features that you haven't yet implemented. \n\n4 The compiler gives you the go ahead, the linked is satisfied, you load your module, run an operation, and bam - a kernel panic. These are the best possible way for your kmod to fail, because it gives you an exact code line of where the panic occurred, and it's easier for you to know what failed, and the state of your system at the time it failed. \n\n5 The compiler is okay, the linker is okay, you run an operation there is no panic. You wait, your system crashes out of the blue, or it prevents you from performing a different unrelated feature. This likely means that you have broken some rule for a vnode lifecycle. The best thing to do here is to read a different filesystem code to see how your approach and their approach differs. The second thing to do is to make sure you are honoring all the lock rules for your given function. \n\nDoing this, one fs feature a time, one kernel panic at a time, you slowly start to get the flow of why things are where they are, what they are supposed to be doing, and why they do it the way they do it. \n\nOf course, there will be times where you will be completely stumped, in times like these you need two things - 1., an understanding of what is actually going wrong, and 2., a detailed report of this for you to ask someone on the fs-mailing list. I've found this group to be extremely prompt and insightful, in many cases they not only fixed the problem I was facing at the time I posted it, but also anticipated future issues I would run into. ","renderText":"<p>Working on this project was pretty nebulous, unlike most of my prior experiences there was no neat little documentation page to copy-paste some code from to get started, neither were there a thousand guides on the do's and dont's, or even a blog post trying to build something that was exactly like what I was building. For the most part, I was on my own, I had nothing apart from a compiler, a debugger, a bunch of manual pages, the source code for a bunch of different filesystems already integrated in the FreeBSD kernel, and a really helpful mentor, and a pretty active mailing list. As I said, all on my own.</p>\n<p>Here's the general flow I followed over the course of this project:</p>\n<ul>\n<li>First, create a generic stubbed function which does nothing more than logging what function was called.</li>\n</ul>\n<p># <em><strong>hfsplus/hfs_vnops.c</strong></em></p>\n<pre><code>static int\nlog_notsupp(struct vop_generic_args *ap)\n{\n\tif (ap-&gt;a_desc &amp;&amp; ap-&gt;a_desc-&gt;vdesc_name) {\n\t\tprintf(&quot;Unimplemented vop: %s\\n&quot;, ap-&gt;a_desc-&gt;vdesc_name);\n\t} else {\n\t\tprintf(&quot;Huh?\\n&quot;);\n\t}\n\n\treturn (EOPNOTSUPP);\n}\n------\n</code></pre>\n<ul>\n<li>Second, try to invoke a filesystem operation. For example - mount, or ls. Take a note of which function were called. This gives you a general idea of the entry and exit points for any given fs operation.</li>\n<li>Third, copy the function from the old port, wrestle with compiler warnings, linker warnings and kernel panics.</li>\n<li>Go back to step 2, repeat until you are stuck, or until the operation does what it is supposed to.</li>\n</ul>\n<p>The issues I ran into where of the following nature for the most part:</p>\n<p>1 The compiler tells you that a function expects different signatures. This was helpful with knowing that functions like VOP_WRITE, VOP_LOCK, VOP_UNLOCK etc. take fewer arguments than they used to.</p>\n<p>2 The compiler tells you that a function does not exist, this lets you know that the canonical way to achieve something has changed. Consult a different FS code to see what.</p>\n<p>3 The linked complains, this just means (for e.g.) that hfs_mount requires certain utility features that you haven't yet implemented.</p>\n<p>4 The compiler gives you the go ahead, the linked is satisfied, you load your module, run an operation, and bam - a kernel panic. These are the best possible way for your kmod to fail, because it gives you an exact code line of where the panic occurred, and it's easier for you to know what failed, and the state of your system at the time it failed.</p>\n<p>5 The compiler is okay, the linker is okay, you run an operation there is no panic. You wait, your system crashes out of the blue, or it prevents you from performing a different unrelated feature. This likely means that you have broken some rule for a vnode lifecycle. The best thing to do here is to read a different filesystem code to see how your approach and their approach differs. The second thing to do is to make sure you are honoring all the lock rules for your given function.</p>\n<p>Doing this, one fs feature a time, one kernel panic at a time, you slowly start to get the flow of why things are where they are, what they are supposed to be doing, and why they do it the way they do it.</p>\n<p>Of course, there will be times where you will be completely stumped, in times like these you need two things - 1., an understanding of what is actually going wrong, and 2., a detailed report of this for you to ask someone on the fs-mailing list. I've found this group to be extremely prompt and insightful, in many cases they not only fixed the problem I was facing at the time I posted it, but also anticipated future issues I would run into.</p>\n"},{"name":"blocks.13","value":{"id":"id_309426.8784290766","rawText":"**f 6: hold on, where are the guardrails?**","renderText":"<p><strong>f 6: hold on, where are the guardrails?</strong></p>\n"},"rawText":"**f 6: hold on, where are the guardrails? how do you inspect a random coredump?**","renderText":"<p><strong>f 6: hold on, where are the guardrails? how do you inspect a random coredump?</strong></p>\n"},{"name":"blocks.14","value":{"id":"id_207071.41304610288","rawText":"If you are like me, reading the 6th point in the last paragraph might have caused you some unease. If your kernel module can cause a system-wide crash well after your supposed operation ran, how do we ever ensure that our kernel is stable? Surely it's impossible to detect these issues during a code review. Second, if these panics are occur after your functions have exited, how do we know what exact thing caused this panic? And how do we know what the panic actually means? Again, it seems impossible to detect any of this without having to do an insane amount of work. \n\nLucky for us (I guess lucky for me), the world is full of people smarter than me who took care of stuff like this. In this section I'm briefly going to talk about a few kernel features that I used to overcome these issues. \n\n- **options INVARIANTS**\n\nWhen you run a debug build of the FreeBSD kernel, you can enable INVARIANTS on it. What this option does is run thousands of runtime checks to ensure that each function enters and exits with the state of the system in a cohesive state. This ensure your kernel panics if these checks don't pass. This is helpful to us because if suppose you hfs_write function mishandles a lock, instead of waiting for a butterfly's wing to flap in order for the system to panic, it panics immediately as it enters or exits your function, pointing you to a very specific place for you to go debugging.\n\n- **options WITNESS**\n\nThis flags builds your kernel such that it keeps track of lock order of your vnodes. It performs runtime assertions which ensure that your locks are being acquired and released in the correct order, minimizing the chances of potential deadlocks. \n\n- **options VFS_DEBUG_LOCKS**\n\nThis comes in handy when you are debugging a lock violation, it lets you see exactly where a lock was acquired, and who holds it. Combined with the the other two options above, it really helps to narrow down where your code went wrong. \n","renderText":"<p>If you are like me, reading the 6th point in the last paragraph might have caused you some unease. If your kernel module can cause a system-wide crash well after your supposed operation ran, how do we ever ensure that our kernel is stable? Surely it's impossible to detect these issues during a code review. Second, if these panics are occur after your functions have exited, how do we know what exact thing caused this panic? And how do we know what the panic actually means? Again, it seems impossible to detect any of this without having to do an insane amount of work.</p>\n<p>Lucky for us (I guess lucky for me), the world is full of people smarter than me who took care of stuff like this. In this section I'm briefly going to talk about a few kernel features that I used to overcome these issues.</p>\n<ul>\n<li><strong>options INVARIANTS</strong></li>\n</ul>\n<p>When you run a debug build of the FreeBSD kernel, you can enable INVARIANTS on it. What this option does is run thousands of runtime checks to ensure that each function enters and exits with the state of the system in a cohesive state. This ensure your kernel panics if these checks don't pass. This is helpful to us because if suppose you hfs_write function mishandles a lock, instead of waiting for a butterfly's wing to flap in order for the system to panic, it panics immediately as it enters or exits your function, pointing you to a very specific place for you to go debugging.</p>\n<ul>\n<li><strong>options WITNESS</strong></li>\n</ul>\n<p>This flags builds your kernel such that it keeps track of lock order of your vnodes. It performs runtime assertions which ensure that your locks are being acquired and released in the correct order, minimizing the chances of potential deadlocks.</p>\n<ul>\n<li><strong>options VFS_DEBUG_LOCKS</strong></li>\n</ul>\n<p>This comes in handy when you are debugging a lock violation, it lets you see exactly where a lock was acquired, and who holds it. Combined with the the other two options above, it really helps to narrow down where your code went wrong.</p>\n"},"rawText":"If you are like me, reading the 6th point in the last paragraph might have caused you some unease. If your kernel module can cause a system-wide crash well after your supposed operation ran, how do we ever ensure that our kernel is stable? Surely it's impossible to detect these issues during a code review. Second, if these panics are occur after your functions have exited, how do we know what exact thing caused this panic? And how do we know what the panic actually means? Again, it seems impossible to detect any of this without having to do an insane amount of work. \n\nLucky for us (I guess lucky for me), the world is full of people smarter than me who took care of stuff like this. In this section I'm briefly going to talk about a few kernel features that I used to overcome these issues. \n\n- **options INVARIANTS**\n\nWhen you run a debug build of the FreeBSD kernel, you can enable INVARIANTS on it. What this option does is run thousands of runtime checks to ensure that each function enters and exits with the state of the system in a cohesive state. This ensure your kernel panics if these checks don't pass. This is helpful to us because if suppose you hfs_write function mishandles a lock, instead of waiting for a butterfly's wing to flap in order for the system to panic, it panics immediately as it enters or exits your function, pointing you to a very specific place for you to go debugging.\n\n- **options WITNESS**\n\nThis flags builds your kernel such that it keeps track of lock order of your vnodes. It performs runtime assertions which ensure that your locks are being acquired and released in the correct order, minimizing the chances of potential deadlocks. \n\n- **options VFS_DEBUG_LOCKS**\n\nThis comes in handy when you are debugging a lock violation, it lets you see exactly where a lock was acquired, and who holds it. Combined with the the other two options above, it really helps to narrow down where your code went wrong. \n","renderText":"<p>If you are like me, reading the 6th point in the last paragraph might have caused you some unease. If your kernel module can cause a system-wide crash well after your supposed operation ran, how do we ever ensure that our kernel is stable? Surely it's impossible to detect these issues during a code review. Second, if these panics are occur after your functions have exited, how do we know what exact thing caused this panic? And how do we know what the panic actually means? Again, it seems impossible to detect any of this without having to do an insane amount of work.</p>\n<p>Lucky for us (I guess lucky for me), the world is full of people smarter than me who took care of stuff like this. In this section I'm briefly going to talk about a few kernel features that I used to overcome these issues.</p>\n<ul>\n<li><strong>options INVARIANTS</strong></li>\n</ul>\n<p>When you run a debug build of the FreeBSD kernel, you can enable INVARIANTS on it. What this option does is run thousands of runtime checks to ensure that each function enters and exits with the state of the system in a cohesive state. This ensure your kernel panics if these checks don't pass. This is helpful to us because if suppose you hfs_write function mishandles a lock, instead of waiting for a butterfly's wing to flap in order for the system to panic, it panics immediately as it enters or exits your function, pointing you to a very specific place for you to go debugging.</p>\n<ul>\n<li><strong>options WITNESS</strong></li>\n</ul>\n<p>This flags builds your kernel such that it keeps track of lock order of your vnodes. It performs runtime assertions which ensure that your locks are being acquired and released in the correct order, minimizing the chances of potential deadlocks.</p>\n<ul>\n<li><strong>options VFS_DEBUG_LOCKS</strong></li>\n</ul>\n<p>This comes in handy when you are debugging a lock violation, it lets you see exactly where a lock was acquired, and who holds it. Combined with the the other two options above, it really helps to narrow down where your code went wrong.</p>\n"},{"name":"blocks.15","value":{"id":"id_346538.79819007515","rawText":"**f -1: parting thoughts**","renderText":"<p><strong>f -1: parting thoughts</strong></p>\n"},"rawText":"**f -1: parting thoughts**","renderText":"<p><strong>f -1: parting thoughts</strong></p>\n"},{"id":"id_936741.1744207627","rawText":"Hopefully, over the course of this summer you will see several updates to this blog post, as I work on the second half of this project which is to enable journalling support. \n\nPrior to starting this project, I had very little idea of how kernel development actually worked. While I had taken an OS class in undergrad, it left me with little more than a theoretical understanding of how things are supposed to work. Prior to this, I also had very little experience working with C, for most of my life I've bounced between Python, JS, and Rust. \n\nIf you made this far, it is only appropriate that I try to give you  pocketable condensed takeways I had from this experience. \n\nFirst, it reminded me that the only way to learn anything daunting is by doing it. The only thing I regret is not doing something like this sooner. Just a few months ago nothing I've written in this blog would have made sense to me. \n\nSecond, the knowledge passed through lore is there for you to access it. I mentioned before that unlike a simple React application, there aren't troves of accessible and readily available guides for you to follow. Rather, it forces you to actually figure out what it is that is going wrong with your system, convert into a meaningful blob of text, and ask people who know better. \n\nAnd finally to satisfy the rule of threes, it is always more about the journey than the destination. While technically speaking the only thing I'm working on is porting a filesystem, the sheer act of starting on such a project required me to actually learn a lot about so many other things. Half the times I tripped and fell, it was not because there was an issue with the hfs code, it was because I hadn't taken into account a completely different thing while running my code. It also gave me a much deeper insight into why C behaves the way that it does. I also never understood why so many OS devs held such deeply rooted opinions they would die for, I now totally see why there are a thousand variants for both BSD and Linux. \n\nMore than anything, it also reaffirmed my love for systems. ","renderText":"<p>Hopefully, over the course of this summer you will see several updates to this blog post, as I work on the second half of this project which is to enable journalling support.</p>\n<p>Prior to starting this project, I had very little idea of how kernel development actually worked. While I had taken an OS class in undergrad, it left me with little more than a theoretical understanding of how things are supposed to work. Prior to this, I also had very little experience working with C, for most of my life I've bounced between Python, JS, and Rust.</p>\n<p>If you made this far, it is only appropriate that I try to give you  pocketable condensed takeways I had from this experience.</p>\n<p>First, it reminded me that the only way to learn anything daunting is by doing it. The only thing I regret is not doing something like this sooner. Just a few months ago nothing I've written in this blog would have made sense to me.</p>\n<p>Second, the knowledge passed through lore is there for you to access it. I mentioned before that unlike a simple React application, there aren't troves of accessible and readily available guides for you to follow. Rather, it forces you to actually figure out what it is that is going wrong with your system, convert into a meaningful blob of text, and ask people who know better.</p>\n<p>And finally to satisfy the rule of threes, it is always more about the journey than the destination. While technically speaking the only thing I'm working on is porting a filesystem, the sheer act of starting on such a project required me to actually learn a lot about so many other things. Half the times I tripped and fell, it was not because there was an issue with the hfs code, it was because I hadn't taken into account a completely different thing while running my code. It also gave me a much deeper insight into why C behaves the way that it does. I also never understood why so many OS devs held such deeply rooted opinions they would die for, I now totally see why there are a thousand variants for both BSD and Linux.</p>\n<p>More than anything, it also reaffirmed my love for systems.</p>\n"}]